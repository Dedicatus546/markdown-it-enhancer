import type { LinkifyItNormalizedOptions, LinkifyItSchemas } from "./types";

export const defaultOptions: LinkifyItNormalizedOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false,
  "---": false,
};

export const defaultSchemas: LinkifyItSchemas = {
  "http:": {
    validate(text, pos, self) {
      const tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp(
          "^\\/\\/" +
            self.re.src_auth +
            self.re.src_host_port_strict +
            self.re.src_path,
          "i",
        );
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)?.[0].length ?? 0;
      }
      return 0;
    },
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate(text, pos, self) {
      const tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp(
          "^" +
            self.re.src_auth +
            // Don't allow single-level domains, because of false positives like '//test'
            // with code comments
            "(?:localhost|(?:(?:" +
            self.re.src_domain +
            ")\\.)+" +
            self.re.src_domain_root +
            ")" +
            self.re.src_port +
            self.re.src_host_terminator +
            self.re.src_path,

          "i",
        );
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self.re.no_http)?.[0].length ?? 0;
      }
      return 0;
    },
  },
  "mailto:": {
    validate(text, pos, self) {
      const tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp(
          "^" + self.re.src_email_name + "@" + self.re.src_host_strict,
          "i",
        );
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)?.[0].length ?? 0;
      }
      return 0;
    },
  },
};

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
export const tlds_2ch_src_re =
  "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
